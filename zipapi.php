<?php
require_once('includes/config.php');
require_once('includes/http_response_code.php');
require_once('includes/URLHasherDB.php');
require_once('includes/urlhash.php');
require_once('includes/REST.php');

/**
* Definition for the ZipAPI web point
*/
class ZipAPI extends REST
{
	private $db_conn = null; //PDO object
	
	/**
	* Constructor
	* @param string $dsn PDO style DSN
	* @param string $user DB username
	* @param string $password DB username's password
	* @return ZipAPI
	*/
	public function __construct($dsn, $user, $password)
	{
		parent::__construct();
		$this->db_conn = new URLHasherDB($dsn, $user, $password);
		$this->db_conn->connect();
	}
	
	/**
	* Parses the request to determine which, if any, ZipAPI function to call based upon Request URI
	* with a little help from .htaccess when necessary
	*/
	public function handle_request()
	{
		$func = '';
		$funcStartLoc = strpos($_SERVER["REQUEST_URI"], "/zipapi/");
		$funcStartLoc+= 8;//end of the zipapi word
		
		$funcEndLoc = strpos($_SERVER["REQUEST_URI"], "/", $funcStartLoc);
		
		if($funcEndLoc === false)
		{
			$funcEndLoc = strpos($_SERVER["REQUEST_URI"], "?", $funcStartLoc);
		}
		
		if($funcEndLoc === false)//still
		{
			$func = strtolower( trim( substr($_SERVER["REQUEST_URI"], $funcStartLoc ) ) );
		}
		else
		{
			$func = strtolower( trim( substr($_SERVER["REQUEST_URI"], $funcStartLoc, $funcEndLoc - $funcStartLoc ) ) );
		}
		
		if((int)method_exists($this,$func) > 0)
		{
			$this->$func();
		}
		else
		{
			$this->respond(404, 'Method not found.');
		}
	}
	
	/**
	* zipapi/zip endpoint  Given a full URL generates a hash for use with the /zipapi/unzip endpoint
	* @param POST['long_url'] string A standard URL
	* @return string
	*/
	private function zip()
	{
		if($this->get_method() == "POST")
		{			
			$parms = $this->get_parameters();
			
			$long_url = ( isset($parms['long_url']) ) ? $parms['long_url'] : '';

			if($long_url != '')
			{
				$long_url = urldecode($long_url);
				
				$hashed_url = $this->db_conn->url_exists($long_url);
				
				if($hashed_url != '')//we've seen this before, update metrics and return it
				{
					$this->db_conn->incr_cache_savings($hashed_url);
					$this->respond(200, $hashed_url);
				}
				else
				{
					//We've got a new URL to hash
					
					$result = false;
					$hashed_urls = hash_url($long_url, 5, false);//generate 5 hashes in case of collision
					$hashed_urls_len = count($hashed_urls);
					
					//just in case there's a hash collision try multiple
					for($i=0; $i < $hashed_urls_len; ++$i)
					{
						$save_hash_result = $this->db_conn->save_hash($long_url, $hashed_urls[$i]);
						
						if($save_hash_result != '')
						{
							$hashed_url = $hashed_urls[$i];
							$result = true;
							break;
						}
					}
					
					if($result)
					{
						$this->respond(200, $hashed_url);
					}
					else
					{
						$this->respond(500, 'Server error.  Please try again.');
					}
				}
			}
			else
			{
				$this->respond(412, 'Required parameter long_url not found.');
			}
		}
		else
		{
			$this->respond(406, 'Please submit as POST');
		}
	}
	
	/**
	* /zipapi/unzip/{hash} Given a previously generated hash, redirects the client to the full URL
	* @param {hash} string Hash generated by /zipapi/zip
	* @return redirects to a web page
	*/
	private function unzip()
	{
		if($this->get_method() == "GET")
		{
			$parms = $this->get_parameters();
			$hashed_url = ( isset($parms['hash']) ) ? $parms['hash'] : '';

			$long_url = $this->db_conn->hash_exists($hashed_url);

			if($long_url != '')
			{
				$this->db_conn->incr_hash_used($hashed_url);//update metrics
				
				$this->respond(0, '', $long_url);//redirect
			}
			else
			{
				$this->respond(404, 'URL not found!');
			}
		}
		else
		{
			$this->respond(406, 'Please submit as GET');
		}
	}
}

//Main method, create a new ZipAPI and handle that request
$zipper = new ZipAPI($db_dsn, $db_user, $db_password);
$zipper->handle_request();
?>